<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>Dorling Cartogram</title>
	<script type="text/javascript" src="http://mbostock.github.com/d3/d3.v2.js"></script>
	<style>
		#chart {
			width: 960px;
			height: 470px;
		}
	</style>
</head>
<body>
<div id="chart"></div>
<button id="restart" onclick="force.start()">Reheat</button>
<button id="update" onclick="update()">Renew</button>

<script>
	var force = d3.layout.force()
		.charge(10)
		.gravity(0.01)
		.size([960, 470]);

	var update;

	d3.json("us-state-centroids.json", function(states) {
		var project = d3.geo.albersUsa(),
			idToNode = {},
			links = [];

		update = function() {
			d3.select("svg").remove();

			var svg = d3.select("#chart").append("svg")
				.attr("width", 960)
				.attr("height", 470)
				.append("g")
				.attr("transform", "translate(50,20)");

			var nodes = states.features.map(function(d) {
				var xy = project(d.geometry.coordinates);
				return idToNode[d.id] = {
					x: xy[0],
					y: xy[1],
					gravity: {x: xy[0], y: xy[1]},
					width: 100,
					height: 50
				};
			});

			force.nodes(nodes)
				.links(links)
				.start()
				.on("tick", function(e) {
					var k = e.alpha,
						kg = k * .02,
						spaceAround = 0.2;

					nodes.forEach(function(a, i) {

						// apply gravity forces
						a.x += (a.gravity.x - a.x) * kg;
						a.y += (a.gravity.y - a.y) * kg;

						nodes.slice(i + 1).forEach(function(b) {
							dx = (a.x - b.x)
							dy = (a.y - b.y)

							adx = Math.abs(dx)
							ady = Math.abs(dy)

							mdx = (1 + spaceAround) * (a.width + b.width) / 2
							mdy = (1 + spaceAround) * (a.height + b.height) / 2

							if (adx < mdx  &&  ady < mdy) {
								l = Math.sqrt(dx * dx + dy * dy)

								lx = (adx - mdx) / l * k
								ly = (ady - mdy) / l * k

								// choose the direction with less overlap
								if (lx > ly && ly > 0)
									lx = 0;
								else if (ly > lx  &&  lx > 0)
									ly = 0;

								dx *= lx
								dy *= ly
								a.x -= dx
								a.y -= dy
								b.x += dx
								b.y += dy
							}
						});
					});

					svg.selectAll("rect")
						.attr("x", function(d) { return d.x- d.width/2; })
						.attr("y", function(d) { return d.y- d.height/2; });
				});


			var g = svg.selectAll("g")
				.data(nodes)
				.enter()
				.append("g")
				.attr("transform", "translate(100,100), scale(0.5)")

			g.append("rect")
				.attr("opacity", 0.75)
				.attr("x", function(d) { return d.x - d.width/2; })
				.attr("y", function(d) { return d.y - d.height/2; })
				.attr("width", function(d, i) { return d.width; })
				.attr("height", function(d, i) { return d.height; })
		};

		update();

	});

</script>

</body>
</html>
